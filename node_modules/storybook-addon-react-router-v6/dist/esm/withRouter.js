function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
import React from "react";
import { makeDecorator } from "@storybook/addons";
import { StoryRouteTree } from "./components/StoryRouteTree";
import { PARAM_KEY } from "./constants";
export var withRouter = makeDecorator({
  name: "withRouter",
  parameterName: PARAM_KEY,
  wrapper: function wrapper(story, context, _ref) {
    var _ref$parameters = _ref.parameters,
      parameters = _ref$parameters === void 0 ? {} : _ref$parameters;
    var _parameters$routePath = parameters.routePath,
      routePath = _parameters$routePath === void 0 ? '*' : _parameters$routePath,
      routeParams = parameters.routeParams,
      routeState = parameters.routeState,
      routeHandle = parameters.routeHandle,
      searchParams = parameters.searchParams,
      outlet = parameters.outlet,
      browserPath = parameters.browserPath,
      loader = parameters.loader,
      action = parameters.action,
      errorElement = parameters.errorElement,
      hydrationData = parameters.hydrationData,
      shouldRevalidate = parameters.shouldRevalidate;
    if (typeof routePath !== 'string') throw new Error("React Router decorator : `path` must be a string");
    if (routeParams !== undefined && _typeof(routeParams) !== 'object') throw new Error("React Router decorator : `params` must be an object with strings as values");
    if (searchParams !== undefined && _typeof(searchParams) !== 'object') throw new Error("React Router decorator : `search` must be an object with strings as values");
    return /*#__PURE__*/React.createElement(StoryRouteTree, {
      browserPath: browserPath,
      routePath: routePath,
      routeParams: routeParams,
      searchParams: searchParams,
      routeState: routeState,
      routeHandle: routeHandle,
      outlet: outlet,
      loader: loader,
      action: action,
      errorElement: errorElement,
      hydrationData: hydrationData,
      shouldRevalidate: shouldRevalidate
    }, story(context));
  }
});